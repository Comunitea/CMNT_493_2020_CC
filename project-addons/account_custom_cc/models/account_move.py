# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import _, api, fields, models


class AccountMove(models.Model):
    _inherit = "account.move"

    cc_type = fields.Selection(
        [
            ("normal", "Special"),  # CMNT ADD: REBU
            ("general", "General"),  # Normal IVA
            ("deposit", "Deposit"),
            ("recoverable_sale", "Recoverable"),
        ],
        "Purchase usage",
        default="normal",
    )

    @api.onchange(
        "line_ids",
        "invoice_payment_term_id",
        "invoice_date_due",
        "invoice_cash_rounding_id",
        "invoice_vendor_bill_id",
    )
    def _onchange_recompute_dynamic_lines(self):
        """
        Al cambiar cantidad o precio, borrar aquí las líneas de base extras
        para recalcularlas
        """
        # CMNT ADD: REBU
        lines2unlink = self.line_ids.filtered(lambda l: l.is_base_extra())
        self.line_ids -= lines2unlink
        # lines2unlink.with_context(check_move_validity=False).unlink()
        return super()._onchange_recompute_dynamic_lines()

    exent_untaxed = fields.Monetary(
        string="Exent Amount",
        store=True,
        readonly=True,
        tracking=True,
        compute="_compute_amount",
    )

    @api.depends(
        "line_ids.debit",
        "line_ids.credit",
        "line_ids.currency_id",
        "line_ids.amount_currency",
        "line_ids.amount_residual",
        "line_ids.amount_residual_currency",
        "line_ids.payment_id.state",
    )
    def _compute_amount(self):
        """
        Add extenet amount in REBU
        Discount ITP amount in itp
        """
        super()._compute_amount()
        exent_untaxed = 0.0
        itp_amount = 0.0
        for move in self:
            if move.type == "entry" or move.is_outbound():
                sign = 1
            else:
                sign = -1
            for line in move.line_ids.filtered(lambda l: l.is_base_extra()):
                exent_untaxed += line.balance * sign
            for line in move.line_ids.filtered(lambda l: l.is_itp_extra()):
                itp_amount += line.balance * sign

        move.exent_untaxed = exent_untaxed
        move.amount_total = move.amount_total + exent_untaxed + itp_amount
        # move.amount_total_signed = move.amount_total + exent_untaxed

    def _recompute_tax_lines(self, recompute_tax_base_amount=False):
        """Compute the dynamic tax lines of the journal entry.

        :param lines_map: The line_ids dispatched by type containing:
            * base_lines: The lines having a tax_ids set.
            * tax_lines: The lines having a tax_line_id set.
            * terms_lines: The lines generated by the payment terms of the
             invoice.
            * rounding_lines: The cash rounding lines of the invoice.

        AÑADIDOS PARA EL CÁLCULO DE REBU
        """
        self.ensure_one()
        in_draft_mode = self != self._origin

        def _serialize_tax_grouping_key(grouping_dict):
            """Serialize the dictionary values to be used in the taxes_map.
            :param grouping_dict: The values returned by '
            _get_tax_grouping_key_from_tax_line' or
            '_get_tax_grouping_key_from_base_line'.
            :return: A string representing the values.
            """
            return "-".join(str(v) for v in grouping_dict.values())

        def _compute_base_line_taxes(base_line):
            """Compute taxes amounts both in company currency /
            foreign currency as the ratio between
            amount_currency & balance could not be the same as the
            expected currency rate.
            The 'amount_currency' value will be set on compute_all(...)
            ['taxes'] in multi-currency.
            :param base_line:   The account.move.line owning the taxes.
            :return:            The result of the compute_all method.
            """

            move = base_line.move_id
            # import pudb.remote
            # pudb.remote.set_trace(term_size=(271, 64))
            if move.is_invoice(include_receipts=True):
                handle_price_include = True
                sign = -1 if move.is_inbound() else 1
                quantity = base_line.quantity
                if base_line.currency_id:
                    price_unit_foreign_curr = (
                        sign * base_line.price_unit * (1 - (base_line.discount / 100.0))
                    )
                    price_unit_comp_curr = base_line.currency_id._convert(
                        price_unit_foreign_curr,
                        move.company_id.currency_id,
                        move.company_id,
                        move.date,
                    )
                else:
                    price_unit_foreign_curr = 0.0
                    price_unit_comp_curr = (
                        sign * base_line.price_unit * (1 - (base_line.discount / 100.0))
                    )
                tax_type = "sale" if move.type.startswith("out_") else "purchase"
                is_refund = move.type in ("out_refund", "in_refund")
            else:
                handle_price_include = False
                quantity = 1.0
                price_unit_foreign_curr = base_line.amount_currency
                price_unit_comp_curr = base_line.balance
                tax_type = (
                    base_line.tax_ids[0].type_tax_use if base_line.tax_ids else None
                )
                is_refund = (tax_type == "sale" and base_line.debit) or (
                    tax_type == "purchase" and base_line.credit
                )

            # CMNT ADD: REBU calculo el impuesto sobre el beneficio
            if base_line.tax_ids.filtered("rebu") and base_line.lot_id:
                price_unit_comp_curr -= base_line.lot_id.standard_price * sign

            balance_taxes_res = base_line.tax_ids._origin.compute_all(
                price_unit_comp_curr,
                currency=base_line.company_currency_id,
                quantity=quantity,
                product=base_line.product_id,
                partner=base_line.partner_id,
                is_refund=is_refund,
                handle_price_include=handle_price_include,
            )

            if move.type == "entry":
                repartition_field = (
                    is_refund
                    and "refund_repartition_line_ids"
                    or "invoice_repartition_line_ids"
                )
                repartition_tags = (
                    base_line.tax_ids.mapped(repartition_field)
                    .filtered(lambda x: x.repartition_type == "base")
                    .tag_ids
                )
                tags_need_inversion = (tax_type == "sale" and not is_refund) or (
                    tax_type == "purchase" and is_refund
                )
                if tags_need_inversion:
                    balance_taxes_res["base_tags"] = base_line._revert_signed_tags(
                        repartition_tags
                    ).ids
                    for tax_res in balance_taxes_res["taxes"]:
                        tax_res["tag_ids"] = base_line._revert_signed_tags(
                            self.env["account.account.tag"].browse(tax_res["tag_ids"])
                        ).ids

            if base_line.currency_id:
                # CMNT ADD: REBU
                if base_line.tax_ids.filtered("rebu") and base_line.lot_id:
                    price_unit_foreign_curr -= base_line.lot_id.standard_price * sign

                # Multi-currencies mode: Taxes are computed both in
                # company's currency / foreign currency.
                amount_currency_taxes_res = base_line.tax_ids._origin.compute_all(
                    price_unit_foreign_curr,
                    currency=base_line.currency_id,
                    quantity=quantity,
                    product=base_line.product_id,
                    partner=base_line.partner_id,
                    is_refund=self.type in ("out_refund", "in_refund"),
                    handle_price_include=handle_price_include,
                )

                if move.type == "entry":
                    repartition_field = (
                        is_refund
                        and "refund_repartition_line_ids"
                        or "invoice_repartition_line_ids"
                    )
                    repartition_tags = (
                        base_line.tax_ids.mapped(repartition_field)
                        .filtered(lambda x: x.repartition_type == "base")
                        .tag_ids
                    )
                    tags_need_inversion = (tax_type == "sale" and not is_refund) or (
                        tax_type == "purchase" and is_refund
                    )
                    if tags_need_inversion:
                        balance_taxes_res["base_tags"] = base_line._revert_signed_tags(
                            repartition_tags
                        ).ids
                        for tax_res in balance_taxes_res["taxes"]:
                            tax_res["tag_ids"] = base_line._revert_signed_tags(
                                self.env["account.account.tag"].browse(
                                    tax_res["tag_ids"]
                                )
                            ).ids

                for b_tax_res, ac_tax_res in zip(
                    balance_taxes_res["taxes"], amount_currency_taxes_res["taxes"]
                ):
                    tax = self.env["account.tax"].browse(b_tax_res["id"])
                    b_tax_res["amount_currency"] = ac_tax_res["amount"]

                    # A tax having a fixed amount must be converted into
                    # the company currency when dealing with a
                    # foreign currency.
                    if tax.amount_type == "fixed":
                        b_tax_res["amount"] = base_line.currency_id._convert(
                            b_tax_res["amount"],
                            move.company_id.currency_id,
                            move.company_id,
                            move.date,
                        )

            # CMNT ADD: REBU EXTRA BASE
            if base_line.tax_ids.filtered("rebu") and base_line.lot_id:
                credit = base_line.quantity * base_line.lot_id.standard_price
                create_method = (
                    in_draft_mode
                    and self.env["account.move.line"].new
                    or self.env["account.move.line"].create
                )
                create_method(
                    {
                        "name": base_line.name + " EXENTO",
                        "move_id": self.id,
                        "partner_id": base_line.partner_id.id,
                        "company_id": base_line.company_id.id,
                        "company_currency_id": base_line.company_currency_id.id,
                        "quantity": base_line.quantity,
                        "date_maturity": False,
                        # 'amount_currency': taxes_map_entry['amount_currency'],
                        "debit": 0.0,
                        "credit": credit,
                        "tax_base_amount": base_line.quantity,
                        "exclude_from_invoice_tab": True,
                        "tax_exigible": base_line.tax_exigible,
                        "base_extra": True,
                        "account_id": base_line.account_id.id,
                    }
                )
                base_line.credit = balance_taxes_res["taxes"][0]["base"] * sign
                # base_line.balance = balance_taxes_res['taxes'][0]['base'] * sign

            # CMNT ADD: ITP EXTRA BASE (SOLO DESDE COMPRAS)
            if base_line.tax_ids.filtered("itp"):
                credit = 0
                for tax in balance_taxes_res["taxes"]:
                    if "ITP" in tax["name"]:
                        credit = tax["amount"]

                # ITP 2/3
                if self.cc_type == "recoverable_sale":
                    credit = credit * 2 / 3

                create_method = (
                    in_draft_mode
                    and self.env["account.move.line"].new
                    or self.env["account.move.line"].create
                )
                create_method(
                    {
                        "name": base_line.name + _(" ITP EXTRA"),
                        "move_id": self.id,
                        "partner_id": base_line.partner_id.id,
                        "company_id": base_line.company_id.id,
                        "company_currency_id": base_line.company_currency_id.id,
                        "quantity": base_line.quantity,
                        "date_maturity": False,
                        # 'amount_currency': taxes_map_entry['amount_currency'],
                        "debit": 0.0,
                        "credit": credit,
                        "tax_base_amount": base_line.quantity,
                        "exclude_from_invoice_tab": True,
                        "tax_exigible": base_line.tax_exigible,
                        "itp_extra": True,
                        "account_id": base_line.account_id.id,
                    }
                )
            # base_line.credit = balance_taxes_res["taxes"][0]["base"] * sign

            # CMNT ADD: ITP 1/3 (SOLO DESDE VENTA POS)
            # La factura de venta de una compra recuperable que se recupera
            # no lleva itp_1_3 y no se calcula
            # CMNT ADD: ITP EXTRA BASE (SOLO DESDE VENTAS)
            if (
                base_line.lot_id
                and base_line.lot_id.itp_1_3
                and base_line.move_id.type in ("out_invoice")
            ):
                create_method = (
                    in_draft_mode
                    and self.env["account.move.line"].new
                    or self.env["account.move.line"].create
                )

                itp_tax = False
                if self.operating_unit_id and self.operating_unit_id.itp_tax_id:
                    itp_tax = self.operating_unit_id.itp_tax_id

                itp_tax_name = itp_tax.name if itp_tax else ""

                # CREATE ITP 1/3
                create_method(
                    {
                        "name": _("ITP 1/3: ") + itp_tax_name,
                        "move_id": self.id,
                        "partner_id": base_line.partner_id.id,
                        "company_id": base_line.company_id.id,
                        "company_currency_id": base_line.company_currency_id.id,
                        "quantity": 0,
                        "date_maturity": False,
                        # 'amount_currency': taxes_map_entry['amount_currency'],
                        "debit": 0.0,
                        "credit": base_line.lot_id.itp_1_3,
                        # "tax_base_amount": base_line.quantity,
                        "exclude_from_invoice_tab": True,
                        # "tax_exigible": base_line.tax_exigible,
                        "itp_extra": True,
                        "account_id":
                        base_line.lot_id.product_id.categ_id.
                        property_account_expense_categ_id.id,
                    }
                )

                # CREATE ITP 1/3 TAX
                rep_line = itp_tax.invoice_repartition_line_ids.filtered(
                    lambda x: x.repartition_type == "tax"
                )
                create_method(
                    {
                        "name": _("TAX ITP 1/3: ") + itp_tax_name,
                        "move_id": self.id,
                        "partner_id": base_line.partner_id.id,
                        "company_id": base_line.company_id.id,
                        "company_currency_id": base_line.company_currency_id.id,
                        "quantity": 0,
                        "date_maturity": False,
                        # 'amount_currency': taxes_map_entry['amount_currency'],
                        "debit": base_line.lot_id.itp_1_3,
                        "credit": 0,
                        # "tax_base_amount": base_line.quantity,
                        "exclude_from_invoice_tab": True,
                        # "tax_exigible": base_line.tax_exigible,
                        "itp_extra": True,
                        "account_id": base_line.account_id.id,
                        "tax_line_id": itp_tax.id,  # Añado como cuota
                        "tax_repartition_line_id": rep_line.id,
                    }
                )

            return balance_taxes_res

        # import pudb.remote
        # pudb.remote.set_trace(term_size=(271, 64))
        # CMNT ADD: REBU quitar lineas exentas
        self.line_ids -= self.line_ids.filtered(lambda l: l.is_base_extra())
        # lines2unlink.with_context(check_move_validity=False).unlink()

        #  CMNT ADD: ITP quitar línea extra
        self.line_ids -= self.line_ids.filtered(lambda l: l.is_itp_extra())

        taxes_map = {}

        # ==== Add tax lines ====
        to_remove = self.env["account.move.line"]
        for line in self.line_ids.filtered("tax_repartition_line_id"):
            grouping_dict = self._get_tax_grouping_key_from_tax_line(line)
            grouping_key = _serialize_tax_grouping_key(grouping_dict)
            if grouping_key in taxes_map:
                # A line with the same key does already exist, we only need one
                # to modify it; we have to drop this one.
                to_remove += line
            else:
                taxes_map[grouping_key] = {
                    "tax_line": line,
                    "balance": 0.0,
                    "amount_currency": 0.0,
                    "tax_base_amount": 0.0,
                    "grouping_dict": False,
                }
        self.line_ids -= to_remove

        # ==== Mount base lines ====
        for line in self.line_ids.filtered(
            lambda line: not line.tax_repartition_line_id
        ):
            # Don't call compute_all if there is no tax.
            if not line.tax_ids:
                line.tag_ids = [(5, 0, 0)]
                continue

            compute_all_vals = _compute_base_line_taxes(line)

            # Assign tags on base line
            line.tag_ids = compute_all_vals["base_tags"]

            tax_exigible = True
            for tax_vals in compute_all_vals["taxes"]:
                grouping_dict = self._get_tax_grouping_key_from_base_line(
                    line, tax_vals
                )
                grouping_key = _serialize_tax_grouping_key(grouping_dict)

                tax_repartition_line = self.env["account.tax.repartition.line"].browse(
                    tax_vals["tax_repartition_line_id"]
                )
                tax = (
                    tax_repartition_line.invoice_tax_id
                    or tax_repartition_line.refund_tax_id
                )

                if tax.tax_exigibility == "on_payment":
                    tax_exigible = False

                taxes_map_entry = taxes_map.setdefault(
                    grouping_key,
                    {
                        "tax_line": None,
                        "balance": 0.0,
                        "amount_currency": 0.0,
                        "tax_base_amount": 0.0,
                        "grouping_dict": False,
                    },
                )
                taxes_map_entry["balance"] += tax_vals["amount"]
                taxes_map_entry["amount_currency"] += tax_vals.get(
                    "amount_currency", 0.0
                )
                taxes_map_entry["tax_base_amount"] += tax_vals["base"]
                taxes_map_entry["grouping_dict"] = grouping_dict
            line.tax_exigible = tax_exigible

        # ==== Process taxes_map ====
        for taxes_map_entry in taxes_map.values():
            # Don't create tax lines with zero balance.
            if self.currency_id.is_zero(
                taxes_map_entry["balance"]
            ) and self.currency_id.is_zero(taxes_map_entry["amount_currency"]):
                taxes_map_entry["grouping_dict"] = False

            tax_line = taxes_map_entry["tax_line"]
            tax_base_amount = (
                -taxes_map_entry["tax_base_amount"]
                if self.is_inbound()
                else taxes_map_entry["tax_base_amount"]
            )

            if not tax_line and not taxes_map_entry["grouping_dict"]:
                continue
            elif tax_line and recompute_tax_base_amount:
                tax_line.tax_base_amount = tax_base_amount
            elif tax_line and not taxes_map_entry["grouping_dict"]:
                # The tax line is no longer used, drop it.
                self.line_ids -= tax_line
            elif tax_line:
                tax_line.update(
                    {
                        "amount_currency": taxes_map_entry["amount_currency"],
                        "debit": taxes_map_entry["balance"] > 0.0
                        and taxes_map_entry["balance"]
                        or 0.0,
                        "credit": taxes_map_entry["balance"] < 0.0
                        and -taxes_map_entry["balance"]
                        or 0.0,
                        "tax_base_amount": tax_base_amount,
                    }
                )
            else:
                create_method = (
                    in_draft_mode
                    and self.env["account.move.line"].new
                    or self.env["account.move.line"].create
                )
                tax_repartition_line_id = taxes_map_entry["grouping_dict"][
                    "tax_repartition_line_id"
                ]
                tax_repartition_line = self.env["account.tax.repartition.line"].browse(
                    tax_repartition_line_id
                )
                tax = (
                    tax_repartition_line.invoice_tax_id
                    or tax_repartition_line.refund_tax_id
                )

                # CMNT ADD: ITP 2/3
                if self.cc_type == "recoverable_sale":
                    taxes_map_entry["balance"] = taxes_map_entry["balance"] * 2 / 3

                tax_line = create_method(
                    {
                        "name": tax.name,
                        "move_id": self.id,
                        "partner_id": line.partner_id.id,
                        "company_id": line.company_id.id,
                        "company_currency_id": line.company_currency_id.id,
                        "quantity": 1.0,
                        "date_maturity": False,
                        "amount_currency": taxes_map_entry["amount_currency"],
                        "debit": taxes_map_entry["balance"] > 0.0
                        and taxes_map_entry["balance"]
                        or 0.0,
                        "credit": taxes_map_entry["balance"] < 0.0
                        and -taxes_map_entry["balance"]
                        or 0.0,
                        "tax_base_amount": tax_base_amount,
                        "exclude_from_invoice_tab": True,
                        "tax_exigible": tax.tax_exigibility == "on_invoice",
                        **taxes_map_entry["grouping_dict"],
                    }
                )

            if in_draft_mode:
                tax_line._onchange_amount_currency()
                tax_line._onchange_balance()


class AccountInvoiceLine(models.Model):
    _inherit = "account.move.line"

    lot_id = fields.Many2one(
        comodel_name="stock.production.lot",
        readonly=False,
        string="Lot",
    )

    base_extra = fields.Boolean("Base extra")
    itp_extra = fields.Boolean("ITP extra")

    def is_base_extra(self):
        """
        Con el boolean no encuenta en líneas .new. Tenemos que buscar por nombre
        """
        self.ensure_one()
        if self.name and "EXENTO" in self.name:
            return True
        else:
            return False

    def is_itp_extra(self):
        """
        Con el boolean no encuenta en líneas .new. Tenemos que buscar por nombre
        """
        self.ensure_one()
        if self.name and "ITP EXTRA" in self.name:
            return True
        else:
            return False

    invoice_type = fields.Selection(
        related="move_id.type", string="Invoice Type", store=True, readonly=True
    )

    @api.model
    def _get_fields_onchange_balance_model(
        self,
        quantity,
        discount,
        balance,
        move_type,
        currency,
        taxes,
        price_subtotal,
        force_computation=False,
    ):
        """
        Se llama en el create del apunte, y no queremos que modifique el precio
        unitartio, sacandolo del balance
        """
        res = super()._get_fields_onchange_balance_model(
            quantity,
            discount,
            balance,
            move_type,
            currency,
            taxes,
            price_subtotal,
            force_computation,
        )
        if taxes and taxes[0].rebu and res.get("price_unit", False):
            res.pop("price_unit")

        return res

    @api.model
    def _get_price_total_and_subtotal_model(
        self,
        price_unit,
        quantity,
        discount,
        currency,
        product,
        partner,
        taxes,
        move_type,
    ):
        """
        Descontar itp del total de la línea
        """
        res = super()._get_price_total_and_subtotal_model(
            price_unit, quantity, discount, currency, product, partner, taxes, move_type
        )
        if taxes and taxes[0].itp:
            res["price_total"] = res["price_subtotal"]
        return res
